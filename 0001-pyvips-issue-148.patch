From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Sat, 4 Jan 2020 11:00:00 +0100
Subject: [PATCH] libvips/pyvips#148


diff --git a/libvips/resample/reduce.c b/libvips/resample/reduce.c
index 1111111..2222222 100644
--- a/libvips/resample/reduce.c
+++ b/libvips/resample/reduce.c
@@ -136,7 +136,7 @@ typedef struct _VipsReduce {
 	 */
 	VipsKernel kernel;
 
-	/* Use centre rather than corner sampling convention.
+	/* Deprecated.
 	 */
 	gboolean centre;
 
@@ -159,11 +159,9 @@ vips_reduce_build( VipsObject *object )
 
 	if( vips_reducev( resample->in, &t[0], reduce->vshrink, 
 		"kernel", reduce->kernel, 
-		"centre", reduce->centre, 
 		NULL ) ||
 		vips_reduceh( t[0], &t[1], reduce->hshrink, 
 			"kernel", reduce->kernel, 
-			"centre", reduce->centre, 
 			NULL ) ||
 		vips_image_write( t[1], resample->out ) )
 		return( -1 );
@@ -210,13 +208,6 @@ vips_reduce_class_init( VipsReduceClass *class )
 		G_STRUCT_OFFSET( VipsReduce, kernel ),
 		VIPS_TYPE_KERNEL, VIPS_KERNEL_LANCZOS3 );
 
-	VIPS_ARG_BOOL( class, "centre", 7, 
-		_( "Centre" ), 
-		_( "Use centre sampling convention" ),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET( VipsReduce, centre ),
-		FALSE );
-
 	/* The old names .. now use h and v everywhere. 
 	 */
 	VIPS_ARG_DOUBLE( class, "xshrink", 8, 
@@ -233,6 +224,15 @@ vips_reduce_class_init( VipsReduceClass *class )
 		G_STRUCT_OFFSET( VipsReduce, vshrink ),
 		1.0, 1000000.0, 1.0 );
 
+	/* We used to let people pick centre or corner, but it's automatic now.
+	 */
+	VIPS_ARG_BOOL( class, "centre", 7, 
+		_( "Centre" ), 
+		_( "Use centre sampling convention" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
+		G_STRUCT_OFFSET( VipsReduce, centre ),
+		FALSE );
+
 }
 
 static void
diff --git a/libvips/resample/reduceh.cpp b/libvips/resample/reduceh.cpp
index 1111111..2222222 100644
--- a/libvips/resample/reduceh.cpp
+++ b/libvips/resample/reduceh.cpp
@@ -66,10 +66,6 @@ typedef struct _VipsReduceh {
 	 */
 	VipsKernel kernel;
 
-	/* Use centre rather than corner sampling convention.
-	 */
-	gboolean centre;
-
 	/* Number of points in kernel.
 	 */
 	int n_point;
@@ -81,6 +77,10 @@ typedef struct _VipsReduceh {
 	int *matrixi[VIPS_TRANSFORM_SCALE + 1];
 	double *matrixf[VIPS_TRANSFORM_SCALE + 1];
 
+	/* Deprecated.
+	 */
+	gboolean centre;
+
 } VipsReduceh;
 
 typedef VipsResampleClass VipsReducehClass;
@@ -194,13 +194,11 @@ reduceh_signed_int_tab( VipsReduceh *reduceh,
 	for( int z = 0; z < bands; z++ ) {
 		int sum;
 
-		sum = reduce_sum<T, int>( in, bands, cx, n );
+		sum = reduce_sum<T, int>( in + z, bands, cx, n );
 		sum = signed_fixed_round( sum ); 
 		sum = VIPS_CLIP( min_value, sum, max_value ); 
 
 		out[z] = sum;
-
-		in += 1;
 	}
 }
 
@@ -216,10 +214,8 @@ reduceh_float_tab( VipsReduceh *reduceh,
 	const T* restrict in = (T *) pin;
 	const int n = reduceh->n_point;
 
-	for( int z = 0; z < bands; z++ ) {
-		out[z] = reduce_sum<T, double>( in, bands, cx, n );
-		in += 1;
-	}
+	for( int z = 0; z < bands; z++ )
+		out[z] = reduce_sum<T, double>( in + z, bands, cx, n );
 }
 
 /* 32-bit int output needs a double intermediate.
@@ -238,10 +234,8 @@ reduceh_unsigned_int32_tab( VipsReduceh *reduceh,
 	for( int z = 0; z < bands; z++ ) {
 		double sum;
 
-		sum = reduce_sum<T, double>( in, bands, cx, n );
-		out[z] = VIPS_CLIP( 0, sum, max_value ); 
-
-		in += 1;
+		sum = reduce_sum<T, double>( in + z, bands, cx, n );
+		out[z] = VIPS_CLIP( 0, sum, max_value );
 	}
 }
 
@@ -258,11 +252,9 @@ reduceh_signed_int32_tab( VipsReduceh *reduceh,
 	for( int z = 0; z < bands; z++ ) {
 		double sum;
 
-		sum = reduce_sum<T, double>( in, bands, cx, n );
+		sum = reduce_sum<T, double>( in + z, bands, cx, n );
 		sum = VIPS_CLIP( min_value, sum, max_value ); 
 		out[z] = sum;
-
-		in += 1;
 	}
 }
 
@@ -282,11 +274,8 @@ reduceh_notab( VipsReduceh *reduceh,
 
 	vips_reduce_make_mask( cx, reduceh->kernel, reduceh->hshrink, x ); 
 
-	for( int z = 0; z < bands; z++ ) {
-		out[z] = reduce_sum<T, double>( in, bands, cx, n );
-
-		in += 1;
-	}
+	for( int z = 0; z < bands; z++ )
+		out[z] = reduce_sum<T, double>( in + z, bands, cx, n );
 }
 
 /* Tried a vector path (see reducev) but it was slower. The vectors for
@@ -319,8 +308,6 @@ vips_reduceh_gen( VipsRegion *out_region, void *seq,
 	s.top = r->top;
 	s.width = r->width * reduceh->hshrink + reduceh->n_point;
 	s.height = r->height;
-	if( reduceh->centre )
-		s.width += 1;
 	if( vips_region_prepare( ir, &s ) )
 		return( -1 );
 
@@ -335,8 +322,6 @@ vips_reduceh_gen( VipsRegion *out_region, void *seq,
 		q = VIPS_REGION_ADDR( out_region, r->left, r->top + y );
 
 		X = r->left * reduceh->hshrink;
-		if( reduceh->centre )
-			X += 0.5;
 
 		/* We want p0 to be the start (ie. x == 0) of the input 
 		 * scanline we are reading from. We can then calculate the p we
@@ -351,7 +336,7 @@ vips_reduceh_gen( VipsRegion *out_region, void *seq,
 			ir->valid.left * ps;
 
 		for( int x = 0; x < r->width; x++ ) {
-			int ix = (int) X;
+			const int ix = (int) X;
 			VipsPel *p = p0 + ix * ps;
 			const int sx = X * VIPS_TRANSFORM_SCALE * 2;
 			const int six = sx & (VIPS_TRANSFORM_SCALE * 2 - 1);
@@ -441,7 +426,6 @@ vips_reduceh_build( VipsObject *object )
 		vips_object_local_array( object, 2 );
 
 	VipsImage *in;
-	int width;
 
 	if( VIPS_OBJECT_CLASS( vips_reduceh_parent_class )->build( object ) )
 		return( -1 );
@@ -499,15 +483,10 @@ vips_reduceh_build( VipsObject *object )
 	in = t[0];
 
 	/* Add new pixels around the input so we can interpolate at the edges.
-	 * In centre mode, we read 0.5 pixels more to the right, so we must
-	 * enlarge a little further.
 	 */
-	width = in->Xsize + reduceh->n_point - 1;
-	if( reduceh->centre )
-		width += 1;
 	if( vips_embed( in, &t[1], 
-		reduceh->n_point / 2 - 1, 0, 
-		width, in->Ysize,
+		0, 0,
+		in->Xsize + reduceh->n_point - 1, in->Ysize,
 		"extend", VIPS_EXTEND_COPY,
 		(void *) NULL ) )
 		return( -1 );
@@ -524,7 +503,7 @@ vips_reduceh_build( VipsObject *object )
 	 * example, vipsthumbnail knows the true reduce factor (including the
 	 * fractional part), we just see the integer part here.
 	 */
-	resample->out->Xsize = VIPS_ROUND_UINT( 
+	resample->out->Xsize = VIPS_CEIL(
 		resample->in->Xsize / reduceh->hshrink );
 	if( resample->out->Xsize <= 0 ) { 
 		vips_error( object_class->nickname, 
@@ -581,13 +560,6 @@ vips_reduceh_class_init( VipsReducehClass *reduceh_class )
 		G_STRUCT_OFFSET( VipsReduceh, kernel ),
 		VIPS_TYPE_KERNEL, VIPS_KERNEL_LANCZOS3 );
 
-	VIPS_ARG_BOOL( reduceh_class, "centre", 7, 
-		_( "Centre" ), 
-		_( "Use centre sampling convention" ),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET( VipsReduceh, centre ),
-		FALSE );
-
 	/* Old name.
 	 */
 	VIPS_ARG_DOUBLE( reduceh_class, "xshrink", 3, 
@@ -597,6 +569,15 @@ vips_reduceh_class_init( VipsReducehClass *reduceh_class )
 		G_STRUCT_OFFSET( VipsReduceh, hshrink ),
 		1, 1000000, 1 );
 
+	/* We used to let people pick centre or corner, but it's automatic now.
+	 */
+	VIPS_ARG_BOOL( reduceh_class, "centre", 7, 
+		_( "Centre" ), 
+		_( "Use centre sampling convention" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
+		G_STRUCT_OFFSET( VipsReduceh, centre ),
+		FALSE );
+
 }
 
 static void
diff --git a/libvips/resample/reducev.cpp b/libvips/resample/reducev.cpp
index 1111111..2222222 100644
--- a/libvips/resample/reducev.cpp
+++ b/libvips/resample/reducev.cpp
@@ -104,10 +104,6 @@ typedef struct _VipsReducev {
 	 */
 	VipsKernel kernel;
 
-	/* Use centre rather than corner sampling convention.
-	 */
-	gboolean centre;
-
 	/* Number of points in kernel.
 	 */
 	int n_point;
@@ -128,6 +124,10 @@ typedef struct _VipsReducev {
 	int n_pass;	
 	Pass pass[MAX_PASS];
 
+	/* Deprecated.
+	 */
+	gboolean centre;
+
 } VipsReducev;
 
 typedef VipsResampleClass VipsReducevClass;
@@ -534,19 +534,18 @@ vips_reducev_gen( VipsRegion *out_region, void *vseq,
 	s.top = r->top * reducev->vshrink;
 	s.width = r->width;
 	s.height = r->height * reducev->vshrink + reducev->n_point;
-	if( reducev->centre )
-		s.height += 1;
 	if( vips_region_prepare( ir, &s ) )
 		return( -1 );
 
 	VIPS_GATE_START( "vips_reducev_gen: work" ); 
 
+	double Y = r->top * reducev->vshrink;
+
 	for( int y = 0; y < r->height; y ++ ) { 
 		VipsPel *q = 
 			VIPS_REGION_ADDR( out_region, r->left, r->top + y );
-		const double Y = (r->top + y) * reducev->vshrink + 
-			(reducev->centre ? 0.5 : 0.0); 
-		VipsPel *p = VIPS_REGION_ADDR( ir, r->left, (int) Y ); 
+		const int py = (int) Y; 
+		VipsPel *p = VIPS_REGION_ADDR( ir, r->left, py ); 
 		const int sy = Y * VIPS_TRANSFORM_SCALE * 2;
 		const int siy = sy & (VIPS_TRANSFORM_SCALE * 2 - 1);
 		const int ty = (siy + 1) >> 1;
@@ -606,13 +605,15 @@ vips_reducev_gen( VipsRegion *out_region, void *vseq,
 		case VIPS_FORMAT_DPCOMPLEX:
 		case VIPS_FORMAT_DOUBLE:
 			reducev_notab<double>( reducev,
-				q, p, ne, lskip, Y - (int) Y );
+				q, p, ne, lskip, Y - py );
 			break;
 
 		default:
 			g_assert_not_reached();
 			break;
 		}
+
+		Y += reducev->vshrink;
 	}
 
 	VIPS_GATE_STOP( "vips_reducev_gen: work" ); 
@@ -647,8 +648,6 @@ vips_reducev_vector_gen( VipsRegion *out_region, void *vseq,
 	s.top = r->top * reducev->vshrink;
 	s.width = r->width;
 	s.height = r->height * reducev->vshrink + reducev->n_point;
-	if( reducev->centre )
-		s.height += 1;
 	if( vips_region_prepare( ir, &s ) )
 		return( -1 );
 
@@ -663,11 +662,11 @@ vips_reducev_vector_gen( VipsRegion *out_region, void *vseq,
 
 	VIPS_GATE_START( "vips_reducev_vector_gen: work" ); 
 
+	double Y = r->top * reducev->vshrink;
+
 	for( int y = 0; y < r->height; y ++ ) { 
 		VipsPel *q = 
 			VIPS_REGION_ADDR( out_region, r->left, r->top + y );
-		const double Y = (r->top + y) * reducev->vshrink + 
-			(reducev->centre ? 0.5 : 0.0); 
 		const int py = (int) Y; 
 		const int sy = Y * VIPS_TRANSFORM_SCALE * 2;
 		const int siy = sy & (VIPS_TRANSFORM_SCALE * 2 - 1);
@@ -682,7 +681,7 @@ vips_reducev_vector_gen( VipsRegion *out_region, void *vseq,
 		printf( "first column of pixel values:\n" ); 
 		for( int i = 0; i < reducev->n_point; i++ ) 
 			printf( "\t%d - %d\n", i, 
-				*VIPS_REGION_ADDR( ir, r->left, r->top + y + i ) ); 
+				*VIPS_REGION_ADDR( ir, r->left, py ) ); 
 #endif /*DEBUG_PIXELS*/
 
 		/* We run our n passes to generate this scanline.
@@ -709,6 +708,8 @@ vips_reducev_vector_gen( VipsRegion *out_region, void *vseq,
 		printf( "pixel result:\n" );
 		printf( "\t%d\n", *q ); 
 #endif /*DEBUG_PIXELS*/
+
+		Y += reducev->vshrink;
 	}
 
 	VIPS_GATE_STOP( "vips_reducev_vector_gen: work" ); 
@@ -787,7 +788,7 @@ vips_reducev_raw( VipsReducev *reducev, VipsImage *in, VipsImage **out )
 
 	*out = vips_image_new();
 	if( vips_image_pipelinev( *out, 
-		VIPS_DEMAND_STYLE_FATSTRIP, in, (void *) NULL ) )
+		VIPS_DEMAND_STYLE_THINSTRIP, in, (void *) NULL ) )
 		return( -1 );
 
 	/* Size output. We need to always round to nearest, so round(), not
@@ -797,7 +798,7 @@ vips_reducev_raw( VipsReducev *reducev, VipsImage *in, VipsImage **out )
 	 * example, vipsthumbnail knows the true reduce factor (including the
 	 * fractional part), we just see the integer part here.
 	 */
-	(*out)->Ysize = VIPS_ROUND_UINT( 
+	(*out)->Ysize = VIPS_CEIL(
 		resample->in->Ysize / reducev->vshrink );
 	if( (*out)->Ysize <= 0 ) { 
 		vips_error( object_class->nickname, 
@@ -830,7 +831,6 @@ vips_reducev_build( VipsObject *object )
 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 4 );
 
 	VipsImage *in;
-	int height;
 
 	if( VIPS_OBJECT_CLASS( vips_reducev_parent_class )->build( object ) )
 		return( -1 );
@@ -863,12 +863,9 @@ vips_reducev_build( VipsObject *object )
 
 	/* Add new pixels around the input so we can interpolate at the edges.
 	 */
-	height = in->Ysize + reducev->n_point - 1;
-	if( reducev->centre )
-		height += 1;
 	if( vips_embed( in, &t[1], 
-		0, reducev->n_point / 2 - 1, 
-		in->Xsize, height, 
+		0, 0,
+		in->Xsize, in->Ysize + reducev->n_point - 1, 
 		"extend", VIPS_EXTEND_COPY,
 		(void *) NULL ) )
 		return( -1 );
@@ -939,13 +936,6 @@ vips_reducev_class_init( VipsReducevClass *reducev_class )
 		G_STRUCT_OFFSET( VipsReducev, kernel ),
 		VIPS_TYPE_KERNEL, VIPS_KERNEL_LANCZOS3 );
 
-	VIPS_ARG_BOOL( reducev_class, "centre", 7, 
-		_( "Centre" ), 
-		_( "Use centre sampling convention" ),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET( VipsReducev, centre ),
-		FALSE );
-
 	/* Old name.
 	 */
 	VIPS_ARG_DOUBLE( reducev_class, "yshrink", 3, 
@@ -955,6 +945,15 @@ vips_reducev_class_init( VipsReducevClass *reducev_class )
 		G_STRUCT_OFFSET( VipsReducev, vshrink ),
 		1, 1000000, 1 );
 
+	/* We used to let people pick centre or corner, but it's automatic now.
+	 */
+	VIPS_ARG_BOOL( reducev_class, "centre", 7, 
+		_( "Centre" ), 
+		_( "Use centre sampling convention" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
+		G_STRUCT_OFFSET( VipsReducev, centre ),
+		FALSE );
+
 }
 
 static void
diff --git a/libvips/resample/resize.c b/libvips/resample/resize.c
index 1111111..2222222 100644
--- a/libvips/resample/resize.c
+++ b/libvips/resample/resize.c
@@ -232,7 +232,6 @@ vips_resize_build( VipsObject *object )
 		g_info( "residual reducev by %g", vscale );
 		if( vips_reducev( in, &t[2], 1.0 / vscale, 
 			"kernel", resize->kernel, 
-			"centre", TRUE, 
 			NULL ) )  
 			return( -1 );
 		in = t[2];
@@ -243,7 +242,6 @@ vips_resize_build( VipsObject *object )
 			hscale );
 		if( vips_reduceh( in, &t[3], 1.0 / hscale, 
 			"kernel", resize->kernel, 
-			"centre", TRUE, 
 			NULL ) )  
 			return( -1 );
 		in = t[3];
diff --git a/libvips/resample/templates.h b/libvips/resample/templates.h
index 1111111..2222222 100644
--- a/libvips/resample/templates.h
+++ b/libvips/resample/templates.h
@@ -321,14 +321,15 @@ calculate_coefficients_triangle( double *c,
 {
 	/* Needs to be in sync with vips_reduce_get_points().
 	 */
-	const int n_points = rint( 2 * shrink ) + 1;
+	const double support = shrink;
+	const int n_points = rint( 2 * support ) + 1;
 
 	int i;
 	double sum; 
 
 	sum = 0;
 	for( i = 0; i < n_points; i++ ) {
-		double xp = (i - (shrink - 0.5) - x) / shrink;
+		double xp = (i - support - x) / shrink;
 
 		double l;
 
@@ -358,14 +359,15 @@ calculate_coefficients_cubic( double *c,
 {
 	/* Needs to be in sync with vips_reduce_get_points().
 	 */
-	const int n_points = rint( 4 * shrink ) + 1; 
+	const double support = 2 * shrink;
+	const int n_points = rint( 2 * support ) + 1;
 
 	int i;
 	double sum; 
 
 	sum = 0;
 	for( i = 0; i < n_points; i++ ) {
-		const double xp = (i - (2 * shrink - 1) - x) / shrink;
+		const double xp = (i - support - x) / shrink;
 		const double axp = VIPS_FABS( xp ); 
 		const double axp2 = axp * axp;
 		const double axp3 = axp2 * axp;
@@ -406,14 +408,20 @@ calculate_coefficients_lanczos( double *c,
 {
 	/* Needs to be in sync with vips_reduce_get_points().
 	 */
-	const int n_points = rint( 2 * a * shrink ) + 1; 
+	const double support = a * shrink;
+	const int n_points = rint( 2 * support ) + 1;
+
+	const double center = (x + 0.5) * shrink - 0.5;
+	const int xmin = VIPS_MAX( 0, rint( center - support ) );
+	const int xmax = VIPS_MIN( n_points, rint( center + support ) ) -
+		xmin;
 
 	int i;
 	double sum; 
 
 	sum = 0;
-	for( i = 0; i < n_points; i++ ) {
-		double xp = (i - (n_points - 2) / 2 - x) / shrink;
+	for( i = 0; i < xmax; i++ ) {
+		double xp = (i + xmin - center) / shrink;
 
 		double l;
 
@@ -432,8 +440,11 @@ calculate_coefficients_lanczos( double *c,
 		sum += l;
 	}
 
-	for( i = 0; i < n_points; i++ ) 
+	for( i = 0; i < xmax; i++ )
 		c[i] /= sum;
+
+	for (; i < n_points; i++)
+		c[i] = 0;
 }
 
 /* Our inner loop for resampling with a convolution. Operate on elements of 
